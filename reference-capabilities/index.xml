<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Overview on Pony Tutorial</title>
    <link>https://epiceric.github.io/pony-tutorial/reference-capabilities.html</link>
    <description>Recent content in Overview on Pony Tutorial</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://epiceric.github.io/pony-tutorial/reference-capabilities/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Aliasing</title>
      <link>https://epiceric.github.io/pony-tutorial/reference-capabilities/aliasing.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://epiceric.github.io/pony-tutorial/reference-capabilities/aliasing.html</guid>
      <description>Aliasing means having more than one reference to the same object, within the same actor. This can be the case for a variable or a field.
In most programming languages, aliasing is pretty simple. You just assign some variable to another variable, and there you go, you have an alias. The variable you assign to has the same type (or some supertype) as what&#39;s being assigned to it, and everything is fine.</description>
    </item>
    
    <item>
      <title>Arrow Types aka Viewpoints</title>
      <link>https://epiceric.github.io/pony-tutorial/reference-capabilities/arrow-types.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://epiceric.github.io/pony-tutorial/reference-capabilities/arrow-types.html</guid>
      <description>When we talked about reference capability composition and viewpoint adaptation, we dealt with cases where we know the reference capability of the origin. However, sometimes we don&#39;t know the precise reference capability of the origin.
When that happens, we can write a viewpoint adapted type, which we call an arrow type because we write it with an -&amp;gt;.
Using this-&amp;gt; as a viewpoint A function with a box receiver can be called with a ref receiver or a val receiver as well since those are both subtypes of box.</description>
    </item>
    
    <item>
      <title>Capability Subtyping</title>
      <link>https://epiceric.github.io/pony-tutorial/reference-capabilities/capability-subtyping.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://epiceric.github.io/pony-tutorial/reference-capabilities/capability-subtyping.html</guid>
      <description>Subtyping is about substitutability. That is, if we need to supply a certain type, what other types can we substitute instead? Reference capabilities factor into this.
Simple substitution First, let&#39;s cover substitution without worrying about ephemeral types (^) or alias types (!). The &amp;lt;: symbol means &amp;ldquo;is a subtype of&amp;rdquo; or alternatively &amp;ldquo;can be substituted for&amp;rdquo;.
 iso &amp;lt;: trn. An iso is read and write unique, and a trn is just write unique, so it&#39;s safe to substitute an iso for a trn.</description>
    </item>
    
    <item>
      <title>Combining Capabilities</title>
      <link>https://epiceric.github.io/pony-tutorial/reference-capabilities/combining-capabilities.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://epiceric.github.io/pony-tutorial/reference-capabilities/combining-capabilities.html</guid>
      <description>When a field of an object is read, its reference capability depends both on the reference capability of the field and the reference capability of the origin, that is, the object the field is being read from.
This is because all the guarantees that the origin reference capability makes have to be maintained for its fields as well.
Viewpoint adaptation The process of combining origin and field capabilities is called viewpoint adaptation.</description>
    </item>
    
    <item>
      <title>Consume and Destructive Read</title>
      <link>https://epiceric.github.io/pony-tutorial/reference-capabilities/consume-and-destructive-read.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://epiceric.github.io/pony-tutorial/reference-capabilities/consume-and-destructive-read.html</guid>
      <description>An important part of Pony&#39;s capabilities is being able to say &amp;ldquo;I&#39;m done with this thing.&amp;rdquo; We&#39;ll cover two means of handling this situation: consuming a variable and destructive reads.
Consuming a variable Sometimes, you want to move an object from one variable to another. In other words, you don&#39;t want to make a new name for the object, exactly, you want to move the object from some existing name to a different one.</description>
    </item>
    
    <item>
      <title>Passing and Sharing References</title>
      <link>https://epiceric.github.io/pony-tutorial/reference-capabilities/passing-and-sharing.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://epiceric.github.io/pony-tutorial/reference-capabilities/passing-and-sharing.html</guid>
      <description>Reference capabilities make it safe to both pass mutable data between actors and to share immutable data amongst actors. Not only that, they make it safe to do it with no copying, no locks, in fact, no runtime overhead at all.
Passing For an object to be mutable, we need to be sure that no other actor can read from or write to that object. The three mutable reference capabilities (iso, trn, and ref) all make that guarantee.</description>
    </item>
    
    <item>
      <title>Recovering Capabilities</title>
      <link>https://epiceric.github.io/pony-tutorial/reference-capabilities/recovering-capabilities.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://epiceric.github.io/pony-tutorial/reference-capabilities/recovering-capabilities.html</guid>
      <description>A recover expression lets you &amp;ldquo;lift&amp;rdquo; the reference capability of the result. A mutable reference capability (iso, trn, or ref) can become any reference capability, and an immutable reference capability (val or box) can become any immutable or opaque reference capability.
Why is this useful? This most straightforward use of recover is to get an iso that you can pass to another actor. But it can be used for many other things as well, such as:</description>
    </item>
    
    <item>
      <title>Reference Capabilities</title>
      <link>https://epiceric.github.io/pony-tutorial/reference-capabilities/reference-capabilities.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://epiceric.github.io/pony-tutorial/reference-capabilities/reference-capabilities.html</guid>
      <description>So if the object is the capability, what controls what we can do with the object? How do we express our access rights on that object?
In Pony, we do it with reference capabilities.
Rights are part of a capability If you open a file in UNIX and get a file descriptor back, that file descriptor is a token that designates an object - but it isn&#39;t a capability. To be a capability, we need to open that file with some permission - some access right.</description>
    </item>
    
    <item>
      <title>Reference Capability Guarantees</title>
      <link>https://epiceric.github.io/pony-tutorial/reference-capabilities/guarantees.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://epiceric.github.io/pony-tutorial/reference-capabilities/guarantees.html</guid>
      <description>Since types are guarantees, it&#39;s useful to talk about what guarantees a reference capability makes.
What is denied We&#39;re going to talk about reference capability guarantees in terms of what&#39;s denied. By this, we mean: what can other variables not do when you have a variable with a certain reference capability?
We need to distinguish between the actor that contains the variable in question and other actors.
This is important because data reads and writes from other actors may occur concurrently.</description>
    </item>
    
    <item>
      <title>Reference Capability Matrix</title>
      <link>https://epiceric.github.io/pony-tutorial/reference-capabilities/capability-matrix.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://epiceric.github.io/pony-tutorial/reference-capabilities/capability-matrix.html</guid>
      <description>At this point, it&#39;s quite possible that you read the previous sections in this chapter and are still pretty confused about the relation between reference capabilities. It&#39;s okay! We have all struggled when learning this part of Pony, too. Once you start working on Pony code, you&#39;ll get a better intuition with them.
In the meantime, if you still feel like all these tidbits in the chapter are still scrambled in your head, there is one resource often presented with Pony that can give you a more visual representation: the reference capability matrix.</description>
    </item>
    
  </channel>
</rss>